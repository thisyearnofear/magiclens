# Auto-generated by Lumenary
##############################################################################
# Dependencies
##############################################################################


from fastapi import FastAPI, HTTPException, Request, status, Body, UploadFile, File, Form
from fastapi.staticfiles import StaticFiles
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.responses import HTMLResponse, Response

from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse, FileResponse, HTMLResponse, Response
from fastapi.exceptions import RequestValidationError

import sys
import os
import asyncio
import logging
import traceback
import contextvars
import httpx
import json
import requests
from pathlib import Path
import builtins

from datetime import datetime, date, time, timedelta
from concurrent.futures import ThreadPoolExecutor
from typing import Callable, Any, TypeVar, Awaitable, List, Optional, Dict, Union, Literal, Annotated, Tuple, Set
from functools import partial, wraps
from uuid import UUID
import uuid

from api.utils import get_swagger_ui_html
from core.user import User

OPENROUTER_API_KEY = os.environ.get("OPENROUTER_API_KEY")





from .models import (
    CreateUserProfileOutputSchema, GetUserProfileOutputSchema, BodyUserServiceGetPublicProfile,
    GetPublicProfileOutputSchema, UpdateUserProfileOutputSchema, GetArtistsOutputSchema,
    GetVideographersOutputSchema, UploadVideoOutputSchema, BodyVideoServiceGetVideos,
    GetVideosOutputSchema, BodyVideoServiceGetVideo, GetVideoOutputSchema, GetMyVideosOutputSchema,
    BodyVideoServiceUpdateVideo, UpdateVideoOutputSchema, BodyVideoServiceDeleteVideo,
    DeleteVideoOutputSchema, GetVideoCategoriesOutputSchema, BodyVideoServiceSearchVideos,
    SearchVideosOutputSchema, UploadAssetOutputSchema, BodyAssetServiceGetAssets, GetAssetsOutputSchema,
    GetMyAssetsOutputSchema, BodyAssetServiceGetAsset, GetAssetOutputSchema, BodyAssetServiceUpdateAsset,
    UpdateAssetOutputSchema, BodyAssetServiceDeleteAsset, DeleteAssetOutputSchema,
    GetAssetCategoriesOutputSchema, BodyAssetServiceSearchAssets, SearchAssetsOutputSchema,
    BodyAssetServiceIncrementAssetUsage, IncrementAssetUsageOutputSchema,
    BodyCollaborationServiceStartCollaboration, StartCollaborationOutputSchema,
    BodyCollaborationServiceGetMyCollaborations, GetMyCollaborationsOutputSchema,
    BodyCollaborationServiceGetCollaborationsForMyVideos, GetCollaborationsForMyVideosOutputSchema,
    BodyCollaborationServiceGetCollaboration, GetCollaborationOutputSchema,
    BodyCollaborationServiceUpdateCollaborationStatus, UpdateCollaborationStatusOutputSchema,
    BodyCollaborationServiceAddOverlayToCollaboration, AddOverlayToCollaborationOutputSchema,
    BodyCollaborationServiceGetCollaborationOverlays, GetCollaborationOverlaysOutputSchema,
    BodyCollaborationServiceUpdateOverlay, UpdateOverlayOutputSchema,
    BodyCollaborationServiceDeleteOverlay, DeleteOverlayOutputSchema, BodyRenderServiceQueueRender,
    QueueRenderOutputSchema, BodyRenderServiceGetRenderStatus, GetRenderStatusOutputSchema,
    BodyRenderServiceGetCollaborationRenders, GetCollaborationRendersOutputSchema,
    BodyRenderServiceCancelRender, CancelRenderOutputSchema, BodyRenderServiceRetryRender,
    RetryRenderOutputSchema, GetRenderQueueStatusOutputSchema,
    BodyRecommendationEngineGetVideoOverlayRecommendations, GetVideoOverlayRecommendationsOutputSchema,
    BodyRecommendationEngineGetSimilarStyleRecommendations, GetSimilarStyleRecommendationsOutputSchema,
    BodyRecommendationEngineTrackRecommendationInteraction, TrackRecommendationInteractionOutputSchema,
    BodyAiAnalysisServiceAnalyzeVideoForOverlays, AnalyzeVideoForOverlaysOutputSchema,
    BodyAiAnalysisServiceGetSmartOverlayRecommendations, GetSmartOverlayRecommendationsOutputSchema
)
from core import user_service, video_service, asset_service, collaboration_service, render_service, recommendation_engine, ai_analysis_service
from api.flow_routes import router as flow_router


###############################################################################
# Logging Setup
###############################################################################
import sys
from loguru import logger
from pathlib import Path
from typing import TypeVar
import traceback

def format_record(record):
    fmt = "{level:<5} | {message}"
    if record["exception"] is not None:
        exc_type, exc_value, exc_traceback = record["exception"]        
        tb_lines = traceback.extract_tb(exc_traceback)
        if tb_lines:
            last_frame = tb_lines[-1]
            error_info = (
                f'\nFile "{last_frame.filename}", line {last_frame.lineno}, in {last_frame.name}\n'
                f'  {last_frame.line}\n'
                f'{exc_type.__name__}: {exc_value}'
            )
            record["message"] += error_info
        
        record["exception"] = None
    
    return fmt + "\n"

logger.remove()
logger.add(
    sys.stderr,
    level="DEBUG",
    format=format_record,
    colorize=True
)

Path("../logs").mkdir(exist_ok=True)
logger.add(
    "../logs/fast_api.log",
    rotation="50 MB",
    retention="10 days",
    level="DEBUG",
    format=format_record
)

# need this to capture print statements
class InterceptHandler:
    def write(self, msg):
        if msg.strip():
            logger.info(msg.strip())
    
    def flush(self):
        pass

sys.stdout = InterceptHandler()

T = TypeVar('T')



##############################################################################
# General App
##############################################################################

app = FastAPI(
    title="Everyday Magic Video",
    docs_url=None
)

# Include Flow blockchain routes
app.include_router(flow_router)

###############################################################################
# Simple Request Logging Middleware
###############################################################################

@app.middleware("http")
async def log_requests(request: Request, call_next):
    request_id = str(uuid.uuid4())[:8]
    
    with logger.contextualize(request_id=request_id):
        start_time = datetime.utcnow()
        
        try:
            response = await call_next(request)
            process_time = (datetime.utcnow() - start_time).total_seconds()
            if "HEAD /docs" not in request.url.path:
              logger.info(f"{request.method} {request.url.path} ({response.status_code}) - {process_time:.3f}s")
            return response
        except Exception as e:
            process_time = (datetime.utcnow() - start_time).total_seconds()
            logger.exception(f"{request.method} {request.url.path} - Failed after {process_time:.3f}s")
            raise
            
###############################################################################
# Error Handler
###############################################################################
@app.exception_handler(Exception)
async def global_exception_handler(request: Request, exc: Exception):
    """Global exception handler for unhandled errors"""
    logger.error(f"Unhandled exception on {request.method} {request.url.path}: {exc}", exc_info=True)
    
    # In production, don't expose error details
    return JSONResponse(
        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
        content={
            "error": "Internal Server Error",
            "message": "An unexpected error occurred"
        }
    )
    
@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request: Request, exc: RequestValidationError):
    """Handle pydantic validation errors"""
    logger.error(f"Validation error on {request.url.path}: {exc.errors()}")
    return JSONResponse(
        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
        content={
            "error": "Validation Error",
            "message": "Invalid request parameters",
            "details": exc.errors()
        }
    )
    
@app.exception_handler(Exception)
async def handle_errors(request: Request, exc: Exception):
    logger.exception(f"Unhandled error: {type(exc).__name__}: {exc}")
    return JSONResponse(
        status_code=500,
        content={"error": "Internal server error", "message": str(exc)}
    )

@app.exception_handler(RequestValidationError)
async def handle_validation_errors(request: Request, exc: RequestValidationError):
    logger.warning(f"Validation error: {exc.errors()}")
    return JSONResponse(
        status_code=422,
        content={"error": "Validation failed", "details": exc.errors()}
    )


app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.head("/docs", include_in_schema=False)
async def health_check():
    return {"status": "healthy"}
    
##############################################################################
# Synchronous Function Helpers
##############################################################################

thread_pool = ThreadPoolExecutor(max_workers=4)

async def run_sync_in_thread(func: Callable[..., Any], *args, **kwargs) -> Any:
    """Runs a synchronous function in a thread pool"""
    loop = asyncio.get_running_loop()
    return await loop.run_in_executor(
        thread_pool,
        partial(func, *args, **kwargs)
    )


##############################################################################
# Custom Docs
##############################################################################

@app.get("/docs", include_in_schema=False)
async def custom_swagger_ui_html():
    return get_swagger_ui_html(
        openapi_url=app.openapi_url,
        title=app.title,
        swagger_ui_parameters={
            "persistAuthorization": False,
            "syntaxHighlight": {"theme": "obsidian"},
        }
    )


##############################################################################
# Normal Routes
##############################################################################






@app.post('/api/user_service/create_user_profile', response_model=CreateUserProfileOutputSchema, operation_id='user_service_create_user_profile')
async def user_service_create_user_profile(avatar: Optional[UploadFile] = File(None), bio: Optional[str] = Form(None), user_type: str = Form(...), username: str = Form(...)) -> CreateUserProfileOutputSchema:
    """
    Create a new user profile with username and user type.
    """
    # Download avatar from the client
    if avatar is not None:
        content_type = avatar.content_type or "application/octet-stream"
        contents = await avatar.read()
        file_size = len(contents)
        avatar = MediaFile(size=file_size, mime_type=content_type, bytes=contents)

    response = await run_sync_in_thread(user_service.create_user_profile,  username=username, user_type=user_type, bio=bio, avatar=avatar)
    return response
    
    




@app.post('/api/user_service/get_user_profile', response_model=GetUserProfileOutputSchema, operation_id='user_service_get_user_profile')
async def user_service_get_user_profile(current_user: User = Depends(get_current_user)) -> GetUserProfileOutputSchema:
    """
    Get the current user&#39;s profile.
    """
    response = await run_sync_in_thread(user_service.get_user_profile, user=current_user)
    return response
    
    




@app.post('/api/user_service/get_public_profile', response_model=GetPublicProfileOutputSchema, operation_id='user_service_get_public_profile')
async def user_service_get_public_profile(body: BodyUserServiceGetPublicProfile = Body(...)) -> GetPublicProfileOutputSchema:
    """
    Get a public user profile by user ID.
    """
    response = await run_sync_in_thread(user_service.get_public_profile, user_id=body.user_id)
    return response
    
    




@app.post('/api/user_service/update_user_profile', response_model=UpdateUserProfileOutputSchema, operation_id='user_service_update_user_profile')
async def user_service_update_user_profile(avatar: Optional[UploadFile] = File(None), bio: Optional[str] = Form(None), username: Optional[str] = Form(None)) -> UpdateUserProfileOutputSchema:
    """
    Update the current user&#39;s profile.
    """
    # Download avatar from the client
    if avatar is not None:
        content_type = avatar.content_type or "application/octet-stream"
        contents = await avatar.read()
        file_size = len(contents)
        avatar = MediaFile(size=file_size, mime_type=content_type, bytes=contents)

    response = await run_sync_in_thread(user_service.update_user_profile,  username=username, bio=bio, avatar=avatar)
    return response
    
    




@app.post('/api/user_service/get_artists', response_model=GetArtistsOutputSchema, operation_id='user_service_get_artists')
async def user_service_get_artists() -> GetArtistsOutputSchema:
    """
    Get all artist profiles for discovery.
    """
    response = await run_sync_in_thread(user_service.get_artists)
    return response
    
    




@app.post('/api/user_service/get_videographers', response_model=GetVideographersOutputSchema, operation_id='user_service_get_videographers')
async def user_service_get_videographers() -> GetVideographersOutputSchema:
    """
    Get all videographer profiles for discovery.
    """
    response = await run_sync_in_thread(user_service.get_videographers)
    return response
    
    




@app.post('/api/video_service/upload_video', response_model=UploadVideoOutputSchema, operation_id='video_service_upload_video')
async def video_service_upload_video(category: str = Form("urban"), description: Optional[str] = Form(None), title: str = Form(...), video_file: UploadFile = File(...)) -> UploadVideoOutputSchema:
    """
    Upload a new video with validation.
    """
    # Download video_file from the client
    if video_file is not None:
        content_type = video_file.content_type or "application/octet-stream"
        contents = await video_file.read()
        file_size = len(contents)
        video_file = MediaFile(size=file_size, mime_type=content_type, bytes=contents)

    response = await run_sync_in_thread(video_service.upload_video,  video_file=video_file, title=title, description=description, category=category)
    return response
    
    




@app.post('/api/video_service/get_videos', response_model=GetVideosOutputSchema, operation_id='video_service_get_videos')
async def video_service_get_videos(body: BodyVideoServiceGetVideos = Body(...)) -> GetVideosOutputSchema:
    """
    Get videos with optional category filtering.
    """
    response = await run_sync_in_thread(video_service.get_videos, category=body.category, limit=body.limit, offset=body.offset)
    return response
    
    




@app.post('/api/video_service/get_video', response_model=GetVideoOutputSchema, operation_id='video_service_get_video')
async def video_service_get_video(body: BodyVideoServiceGetVideo = Body(...)) -> GetVideoOutputSchema:
    """
    Get a specific video by ID.
    """
    response = await run_sync_in_thread(video_service.get_video, video_id=body.video_id)
    return response
    
    




@app.post('/api/video_service/get_my_videos', response_model=GetMyVideosOutputSchema, operation_id='video_service_get_my_videos')
async def video_service_get_my_videos(current_user: User = Depends(get_current_user)) -> GetMyVideosOutputSchema:
    """
    Get videos uploaded by the current user.
    """
    response = await run_sync_in_thread(video_service.get_my_videos, user=current_user)
    return response
    
    




@app.post('/api/video_service/update_video', response_model=UpdateVideoOutputSchema, operation_id='video_service_update_video')
async def video_service_update_video(body: BodyVideoServiceUpdateVideo = Body(...)) -> UpdateVideoOutputSchema:
    """
    Update video metadata (only by owner).
    """
    response = await run_sync_in_thread(video_service.update_video,  video_id=body.video_id, title=body.title, description=body.description, category=body.category)
    return response
    
    




@app.post('/api/video_service/delete_video', response_model=DeleteVideoOutputSchema, operation_id='video_service_delete_video')
async def video_service_delete_video(body: BodyVideoServiceDeleteVideo = Body(...)) -> DeleteVideoOutputSchema:
    """
    Delete a video (only by owner).
    """
    response = await run_sync_in_thread(video_service.delete_video,  video_id=body.video_id)
    return response
    
    




@app.post('/api/video_service/get_video_categories', response_model=GetVideoCategoriesOutputSchema, operation_id='video_service_get_video_categories')
async def video_service_get_video_categories() -> GetVideoCategoriesOutputSchema:
    """
    Get list of available video categories.
    """
    response = await run_sync_in_thread(video_service.get_video_categories)
    return response
    
    




@app.post('/api/video_service/search_videos', response_model=SearchVideosOutputSchema, operation_id='video_service_search_videos')
async def video_service_search_videos(body: BodyVideoServiceSearchVideos = Body(...)) -> SearchVideosOutputSchema:
    """
    Search videos by title or description.
    """
    response = await run_sync_in_thread(video_service.search_videos, query=body.query, category=body.category, limit=body.limit)
    return response
    
    




@app.post('/api/asset_service/upload_asset', response_model=UploadAssetOutputSchema, operation_id='asset_service_upload_asset')
async def asset_service_upload_asset(asset_file: UploadFile = File(...), category: str = Form("effects"), is_public: bool = Form(True), name: str = Form(...)) -> UploadAssetOutputSchema:
    """
    Upload a new artist asset.
    """
    # Download asset_file from the client
    if asset_file is not None:
        content_type = asset_file.content_type or "application/octet-stream"
        contents = await asset_file.read()
        file_size = len(contents)
        asset_file = MediaFile(size=file_size, mime_type=content_type, bytes=contents)

    response = await run_sync_in_thread(asset_service.upload_asset,  asset_file=asset_file, name=name, category=category, is_public=is_public)
    return response
    
    




@app.post('/api/asset_service/get_assets', response_model=GetAssetsOutputSchema, operation_id='asset_service_get_assets')
async def asset_service_get_assets(body: BodyAssetServiceGetAssets = Body(...)) -> GetAssetsOutputSchema:
    """
    Get assets with optional filtering.
    """
    response = await run_sync_in_thread(asset_service.get_assets, category=body.category, artist_id=body.artist_id, limit=body.limit, offset=body.offset)
    return response
    
    




@app.post('/api/asset_service/get_my_assets', response_model=GetMyAssetsOutputSchema, operation_id='asset_service_get_my_assets')
async def asset_service_get_my_assets(current_user: User = Depends(get_current_user)) -> GetMyAssetsOutputSchema:
    """
    Get assets uploaded by the current user.
    """
    response = await run_sync_in_thread(asset_service.get_my_assets, user=current_user)
    return response
    
    




@app.post('/api/asset_service/get_asset', response_model=GetAssetOutputSchema, operation_id='asset_service_get_asset')
async def asset_service_get_asset(body: BodyAssetServiceGetAsset = Body(...)) -> GetAssetOutputSchema:
    """
    Get a specific asset by ID.
    """
    response = await run_sync_in_thread(asset_service.get_asset, asset_id=body.asset_id)
    return response
    
    




@app.post('/api/asset_service/update_asset', response_model=UpdateAssetOutputSchema, operation_id='asset_service_update_asset')
async def asset_service_update_asset(body: BodyAssetServiceUpdateAsset = Body(...)) -> UpdateAssetOutputSchema:
    """
    Update asset metadata (only by owner).
    """
    response = await run_sync_in_thread(asset_service.update_asset,  asset_id=body.asset_id, name=body.name, category=body.category, is_public=body.is_public)
    return response
    
    




@app.post('/api/asset_service/delete_asset', response_model=DeleteAssetOutputSchema, operation_id='asset_service_delete_asset')
async def asset_service_delete_asset(body: BodyAssetServiceDeleteAsset = Body(...)) -> DeleteAssetOutputSchema:
    """
    Delete an asset (only by owner).
    """
    response = await run_sync_in_thread(asset_service.delete_asset,  asset_id=body.asset_id)
    return response
    
    




@app.post('/api/asset_service/get_asset_categories', response_model=GetAssetCategoriesOutputSchema, operation_id='asset_service_get_asset_categories')
async def asset_service_get_asset_categories() -> GetAssetCategoriesOutputSchema:
    """
    Get list of available asset categories.
    """
    response = await run_sync_in_thread(asset_service.get_asset_categories)
    return response
    
    




@app.post('/api/asset_service/search_assets', response_model=SearchAssetsOutputSchema, operation_id='asset_service_search_assets')
async def asset_service_search_assets(body: BodyAssetServiceSearchAssets = Body(...)) -> SearchAssetsOutputSchema:
    """
    Search assets by name.
    """
    response = await run_sync_in_thread(asset_service.search_assets, query=body.query, category=body.category, limit=body.limit)
    return response
    
    




@app.post('/api/asset_service/increment_asset_usage', response_model=IncrementAssetUsageOutputSchema, operation_id='asset_service_increment_asset_usage')
async def asset_service_increment_asset_usage(body: BodyAssetServiceIncrementAssetUsage = Body(...)) -> IncrementAssetUsageOutputSchema:
    """
    Increment usage count when asset is used in collaboration.
    """
    response = await run_sync_in_thread(asset_service.increment_asset_usage,  asset_id=body.asset_id)
    return response
    
    




@app.post('/api/collaboration_service/start_collaboration', response_model=StartCollaborationOutputSchema, operation_id='collaboration_service_start_collaboration')
async def collaboration_service_start_collaboration(body: BodyCollaborationServiceStartCollaboration = Body(...)) -> StartCollaborationOutputSchema:
    """
    Start a new collaboration on a video.
    """
    response = await run_sync_in_thread(collaboration_service.start_collaboration,  video_id=body.video_id, revenue_split=body.revenue_split)
    return response
    
    




@app.post('/api/collaboration_service/get_my_collaborations', response_model=GetMyCollaborationsOutputSchema, operation_id='collaboration_service_get_my_collaborations')
async def collaboration_service_get_my_collaborations(body: BodyCollaborationServiceGetMyCollaborations = Body(...)) -> GetMyCollaborationsOutputSchema:
    """
    Get collaborations for the current user.
    """
    response = await run_sync_in_thread(collaboration_service.get_my_collaborations,  status=body.status)
    return response
    
    




@app.post('/api/collaboration_service/get_collaborations_for_my_videos', response_model=GetCollaborationsForMyVideosOutputSchema, operation_id='collaboration_service_get_collaborations_for_my_videos')
async def collaboration_service_get_collaborations_for_my_videos(body: BodyCollaborationServiceGetCollaborationsForMyVideos = Body(...)) -> GetCollaborationsForMyVideosOutputSchema:
    """
    Get collaborations on videos uploaded by the current user.
    """
    response = await run_sync_in_thread(collaboration_service.get_collaborations_for_my_videos,  status=body.status)
    return response
    
    




@app.post('/api/collaboration_service/get_collaboration', response_model=GetCollaborationOutputSchema, operation_id='collaboration_service_get_collaboration')
async def collaboration_service_get_collaboration(body: BodyCollaborationServiceGetCollaboration = Body(...)) -> GetCollaborationOutputSchema:
    """
    Get a specific collaboration by ID.
    """
    response = await run_sync_in_thread(collaboration_service.get_collaboration, collaboration_id=body.collaboration_id)
    return response
    
    




@app.post('/api/collaboration_service/update_collaboration_status', response_model=UpdateCollaborationStatusOutputSchema, operation_id='collaboration_service_update_collaboration_status')
async def collaboration_service_update_collaboration_status(body: BodyCollaborationServiceUpdateCollaborationStatus = Body(...)) -> UpdateCollaborationStatusOutputSchema:
    """
    Update collaboration status.
    """
    response = await run_sync_in_thread(collaboration_service.update_collaboration_status,  collaboration_id=body.collaboration_id, status=body.status, submission_notes=body.submission_notes, feedback=body.feedback)
    return response
    
    




@app.post('/api/collaboration_service/add_overlay_to_collaboration', response_model=AddOverlayToCollaborationOutputSchema, operation_id='collaboration_service_add_overlay_to_collaboration')
async def collaboration_service_add_overlay_to_collaboration(body: BodyCollaborationServiceAddOverlayToCollaboration = Body(...)) -> AddOverlayToCollaborationOutputSchema:
    """
    Add an overlay to a collaboration.
    """
    response = await run_sync_in_thread(collaboration_service.add_overlay_to_collaboration,  collaboration_id=body.collaboration_id, asset_id=body.asset_id, position_data=body.position_data, timing_data=body.timing_data, layer_order=body.layer_order)
    return response
    
    




@app.post('/api/collaboration_service/get_collaboration_overlays', response_model=GetCollaborationOverlaysOutputSchema, operation_id='collaboration_service_get_collaboration_overlays')
async def collaboration_service_get_collaboration_overlays(body: BodyCollaborationServiceGetCollaborationOverlays = Body(...)) -> GetCollaborationOverlaysOutputSchema:
    """
    Get all overlays for a collaboration.
    """
    response = await run_sync_in_thread(collaboration_service.get_collaboration_overlays,  collaboration_id=body.collaboration_id)
    return response
    
    




@app.post('/api/collaboration_service/update_overlay', response_model=UpdateOverlayOutputSchema, operation_id='collaboration_service_update_overlay')
async def collaboration_service_update_overlay(body: BodyCollaborationServiceUpdateOverlay = Body(...)) -> UpdateOverlayOutputSchema:
    """
    Update an overlay (only by the artist who created it).
    """
    response = await run_sync_in_thread(collaboration_service.update_overlay,  overlay_id=body.overlay_id, position_data=body.position_data, timing_data=body.timing_data, layer_order=body.layer_order)
    return response
    
    




@app.post('/api/collaboration_service/delete_overlay', response_model=DeleteOverlayOutputSchema, operation_id='collaboration_service_delete_overlay')
async def collaboration_service_delete_overlay(body: BodyCollaborationServiceDeleteOverlay = Body(...)) -> DeleteOverlayOutputSchema:
    """
    Delete an overlay (only by the artist who created it).
    """
    response = await run_sync_in_thread(collaboration_service.delete_overlay,  overlay_id=body.overlay_id)
    return response
    
    




@app.post('/api/render_service/queue_render', response_model=QueueRenderOutputSchema, operation_id='render_service_queue_render')
async def render_service_queue_render(body: BodyRenderServiceQueueRender = Body(...)) -> QueueRenderOutputSchema:
    """
    Queue a new render job for a collaboration.
    """
    response = await run_sync_in_thread(render_service.queue_render,  collaboration_id=body.collaboration_id, render_settings=body.render_settings)
    return response
    
    




@app.post('/api/render_service/get_render_status', response_model=GetRenderStatusOutputSchema, operation_id='render_service_get_render_status')
async def render_service_get_render_status(body: BodyRenderServiceGetRenderStatus = Body(...)) -> GetRenderStatusOutputSchema:
    """
    Get the status of a render job.
    """
    response = await run_sync_in_thread(render_service.get_render_status,  render_id=body.render_id)
    return response
    
    




@app.post('/api/render_service/get_collaboration_renders', response_model=GetCollaborationRendersOutputSchema, operation_id='render_service_get_collaboration_renders')
async def render_service_get_collaboration_renders(body: BodyRenderServiceGetCollaborationRenders = Body(...)) -> GetCollaborationRendersOutputSchema:
    """
    Get all renders for a collaboration.
    """
    response = await run_sync_in_thread(render_service.get_collaboration_renders,  collaboration_id=body.collaboration_id)
    return response
    
    




@app.post('/api/render_service/cancel_render', response_model=CancelRenderOutputSchema, operation_id='render_service_cancel_render')
async def render_service_cancel_render(body: BodyRenderServiceCancelRender = Body(...)) -> CancelRenderOutputSchema:
    """
    Cancel a queued or processing render.
    """
    response = await run_sync_in_thread(render_service.cancel_render,  render_id=body.render_id)
    return response
    
    




@app.post('/api/render_service/retry_render', response_model=RetryRenderOutputSchema, operation_id='render_service_retry_render')
async def render_service_retry_render(body: BodyRenderServiceRetryRender = Body(...)) -> RetryRenderOutputSchema:
    """
    Retry a failed render.
    """
    response = await run_sync_in_thread(render_service.retry_render,  render_id=body.render_id)
    return response
    
    




@app.post('/api/render_service/get_render_queue_status', response_model=GetRenderQueueStatusOutputSchema, operation_id='render_service_get_render_queue_status')
async def render_service_get_render_queue_status() -> GetRenderQueueStatusOutputSchema:
    """
    Get general render queue statistics.
    """
    response = await run_sync_in_thread(render_service.get_render_queue_status)
    return response
    
    




@app.post('/api/recommendation_engine/get_video_overlay_recommendations', response_model=GetVideoOverlayRecommendationsOutputSchema, operation_id='recommendation_engine_get_video_overlay_recommendations')
async def recommendation_engine_get_video_overlay_recommendations(body: BodyRecommendationEngineGetVideoOverlayRecommendations = Body(...)) -> GetVideoOverlayRecommendationsOutputSchema:
    """
    Get overlay recommendations for a video with multiple recommendation strategies.
    """
    response = await run_sync_in_thread(recommendation_engine.get_video_overlay_recommendations,  video_id=body.video_id, recommendation_type=body.recommendation_type, limit=body.limit)
    return response
    
    




@app.post('/api/recommendation_engine/get_similar_style_recommendations', response_model=GetSimilarStyleRecommendationsOutputSchema, operation_id='recommendation_engine_get_similar_style_recommendations')
async def recommendation_engine_get_similar_style_recommendations(body: BodyRecommendationEngineGetSimilarStyleRecommendations = Body(...)) -> GetSimilarStyleRecommendationsOutputSchema:
    """
    Get recommendations similar to a specific asset.
    """
    response = await run_sync_in_thread(recommendation_engine.get_similar_style_recommendations,  video_id=body.video_id, reference_asset_id=body.reference_asset_id, limit=body.limit)
    return response
    
    




@app.post('/api/recommendation_engine/track_recommendation_interaction', response_model=TrackRecommendationInteractionOutputSchema, operation_id='recommendation_engine_track_recommendation_interaction')
async def recommendation_engine_track_recommendation_interaction(body: BodyRecommendationEngineTrackRecommendationInteraction = Body(...)) -> TrackRecommendationInteractionOutputSchema:
    """
    Track user interaction with recommendations for learning.
    """
    response = await run_sync_in_thread(recommendation_engine.track_recommendation_interaction,  video_id=body.video_id, asset_id=body.asset_id, action=body.action, metadata=body.metadata)
    return response
    
    




@app.post('/api/ai_analysis_service/analyze_video_for_overlays', response_model=AnalyzeVideoForOverlaysOutputSchema, operation_id='ai_analysis_service_analyze_video_for_overlays')
async def ai_analysis_service_analyze_video_for_overlays(body: BodyAiAnalysisServiceAnalyzeVideoForOverlays = Body(...)) -> AnalyzeVideoForOverlaysOutputSchema:
    """
    Analyze a video and return AI-powered overlay recommendations.
    """
    response = await run_sync_in_thread(ai_analysis_service.analyze_video_for_overlays,  video_id=body.video_id)
    return response
    
    




@app.post('/api/ai_analysis_service/get_smart_overlay_recommendations', response_model=GetSmartOverlayRecommendationsOutputSchema, operation_id='ai_analysis_service_get_smart_overlay_recommendations')
async def ai_analysis_service_get_smart_overlay_recommendations(body: BodyAiAnalysisServiceGetSmartOverlayRecommendations = Body(...)) -> GetSmartOverlayRecommendationsOutputSchema:
    """
    Get AI-recommended overlays for a specific video.
    """
    response = await run_sync_in_thread(ai_analysis_service.get_smart_overlay_recommendations,  video_id=body.video_id, limit=body.limit)
    return response
    
    

